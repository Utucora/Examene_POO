ğŸŸ¦ I. TEORIE ESENÈšIALÄ‚ (TOT CE PICÄ‚ LA EXAMEN)
ğŸ”¹ 1. Clase abstracte
O clasÄƒ abstractÄƒ:
poate conÈ›ine:
âœ” metode abstracte
âœ” metode concrete
âœ” cÃ¢mpuri
âœ” constructori
âœ” blocuri normale
nu poate fi instanÈ›iatÄƒ
poate fi moÈ™tenitÄƒ cu extends
o subclasÄƒ care nu implementeazÄƒ toate metodele abstracte â†’ devine abstractÄƒ

abstract class Shape {
    abstract double area();     // metodÄƒ abstractÄƒ
    void print() {              // metodÄƒ concretÄƒ
        System.out.println("Shape");
    }
}


Reguli importante:
o clasÄƒ abstractÄƒ poate avea constructor
(foarte mulÈ›i greÈ™esc la asta!)
o clasÄƒ abstractÄƒ NU poate fi final
o metodÄƒ abstractÄƒ NU poate fi finalÄƒ sau private sau static


ğŸ”¹ 2. InterfeÈ›e
Ãn Java modern (dupÄƒ Java 8+):
O interfaÈ›Äƒ poate conÈ›ine:
metode abstracte (implicit public abstract)
metode default
metode static
cÃ¢mpuri public static final (implicit)
O clasÄƒ poate implementa oricÃ¢te interfeÈ›e.
Exemplu:
interface Drawable {
    void draw();               // abstract
    default void info() {      // default
        System.out.println("Drawable");
    }
    static void help() {       // static
        System.out.println("help");
    }
}

ğŸ”¹ 3. InterfaÈ›Äƒ vs ClasÄƒ abstractÄƒ â€” diferenÈ›e pentru examen
CaracteristicÄƒ	                  InterfaÈ›Äƒ              	      ClasÄƒ abstractÄƒ
Poate avea cÃ¢mpuri?        	âœ” dar doar public static final	      âœ” orice tip
Poate avea constructor?              	âŒ	                              âœ”
Poate avea cod Ã®n metode?      	âœ” default/static              	âœ” metode concrete
MoÈ™tenire multiplÄƒ?          	âœ” (mai multe interfeÈ›e)	             âŒ doar una
Poate fi instanÈ›iatÄƒ?	                âŒ	                             âŒ


ğŸ”¹ 4. Default methods Ã®n interfeÈ›e

interface I {
    default void f() { System.out.println("I"); }
}
class A implements I {
    public void f() { System.out.println("A"); }
}
âœ” pot fi suprascrise
âœ” se moÈ™tenesc dacÄƒ nu sunt suprascrise
âœ” rezolvÄƒ â€œproblema diamantuluiâ€ cu regulÄƒ:
â€œclasa cÃ¢È™tigÄƒ Ã®n faÈ›a interfeÈ›eiâ€



ğŸ”¹ 5. Conflict de default methods
DacÄƒ douÄƒ interfeÈ›e au aceeaÈ™i metodÄƒ default â†’ clasa trebuie sÄƒ o rezolve:
interface A { default void f() {} }
interface B { default void f() {} }

class C implements A, B {
    public void f() { A.super.f(); } // obligatoriu override
}


ğŸ”¹ 6. Static methods Ã®n interfeÈ›e
se apeleazÄƒ cu numele interfeÈ›ei â†’ I.m()
nu se moÈ™tenesc de clasele care o implementeazÄƒ

ğŸ”¹ 7. CÃ¢nd alegi clasÄƒ abstractÄƒ vs interfaÈ›Äƒ?
interfaÈ›Äƒ â†’ pentru comportament
clasÄƒ abstractÄƒ â†’ pentru structurÄƒ comunÄƒ + cod reutilizabil
La examene apar Ã®ntrebÄƒri gen:
â€Este corect aleasÄƒ interfaÈ›a / clasa abstractÄƒ Ã®n cod?â€





1. Ce este adevÄƒrat despre clasele abstracte?
A. Pot fi instanÈ›iate
B. Pot conÈ›ine metode non-abstracte
C. Trebuie sÄƒ conÈ›inÄƒ cel puÈ›in o metodÄƒ abstractÄƒ
D. Nu pot avea constructori

âœ” CORECT: B
Clasele abstracte pot conÈ›ine metode concrete.
GreÈ™it la examen ar fi: â€œtrebuie sÄƒ aibÄƒ mÄƒcar o metodÄƒ abstractÄƒâ€ â†’ FALS.


2. Ce este adevÄƒrat despre interfeÈ›e?
A. Pot avea variabile non-final
B. Pot avea metode private
C. Metodele default trebuie suprascrise Ã®n clase
D. Toate metodele sunt implicit abstract È™i public

âœ” CORECT: D
ExplicaÈ›ie:
InterfeÈ›ele nu pot avea variabile non-final â†’ A e fals.
InterfeÈ›ele pot avea metode private (din Java 9) â†’ B e adevÄƒratÄƒ, dar nu e opÈ›iunea corectÄƒ aici fiindcÄƒ existÄƒ un rÄƒspuns mai bun.
â€œMetodele default trebuie suprascriseâ€ â€” FALS.
âœ” Corect este:
D. Toate metodele sunt implicit abstract È™i public
(cu excepÈ›ia default / private / static)



3. Ce se Ã®ntÃ¢mplÄƒ aici?
abstract class A {
    abstract void f();
    void g() { System.out.println("A"); }
}

class B extends A {}


A. CompileazÄƒ fÄƒrÄƒ probleme
B. Eroare: B trebuie sÄƒ implementeze f()
C. Eroare: g() trebuie sÄƒ fie abstractÄƒ
D. Eroare: A nu poate avea metode concrete


âœ” CORECT: B
B nu implementeazÄƒ f(), deci trebuie sÄƒ fie declaratÄƒ abstractÄƒ.



4. Ce se afiÈ™eazÄƒ?
interface I {
    default void f() { System.out.println("I"); }
}

class A implements I {
    public void f() { System.out.println("A"); }
}

public class Main {
    public static void main(String[] args) {
        I i = new A();
        i.f();
    }
}
A. I
B. A
C. eroare
D. depinde de compilator

âœ” CORECT: B
Da, este overriding.


5. Ce se Ã®ntÃ¢mplÄƒ?
interface A { default void f() {} }
interface B { default void f() {} }

class C implements A, B {}
A. totul e ok
B. eroare la compilare
C. se executÄƒ f() din A
D. se executÄƒ f() din B


âœ” CORECT: B

DacÄƒ douÄƒ interfeÈ›e conÈ›in aceeaÈ™i metodÄƒ default:
interface A { default void f() {} }
interface B { default void f() {} }

class C implements A, B {}
â†’ Eroare de compilare: â€duplicate default methodsâ€.
Clasa C este OBLIGATÄ‚ sÄƒ rezolve conflictul:


6. Care este adevÄƒratÄƒ?
A. O interfaÈ›Äƒ poate extinde o clasÄƒ
B. O clasÄƒ abstractÄƒ poate implementa interfeÈ›e
C. O clasÄƒ poate extinde mai multe clase abstracte
D. O interfaÈ›Äƒ poate avea constructori

âœ” CORECT: B
O clasÄƒ abstractÄƒ POATE implementa interfeÈ›e.
O interfaÈ›Äƒ NU poate extinde o clasÄƒ.
O clasÄƒ NU poate extinde mai multe clase.
InterfeÈ›ele NU au constructori.


7. Ce este adevÄƒrat despre metodele default?
A. pot fi private
B. pot fi finale
C. pot fi suprascrise
D. trebuie apelate cu numele interfeÈ›ei

7. Ai rÄƒspuns: C
âœ” CORECT: C
Metodele default pot fi suprascrise.


8. Ce se Ã®ntÃ¢mplÄƒ?
interface X { void f(); }
abstract class Y implements X {}
class Z extends Y {}
A. Z este abstractÄƒ
B. Z trebuie sÄƒ implementeze f()
C. Codul compileazÄƒ fÄƒrÄƒ probleme
D. Y nu poate implementa X

âœ” CORECT: B
AnalizÄƒm:
interface X { void f(); }   // metodÄƒ abstractÄƒ
abstract class Y implements X {}  // Y nu implementeazÄƒ f() â†’ e abstractÄƒ
class Z extends Y {} // Z NU implementeazÄƒ f() â†’ trebuie È™i ea sÄƒ fie abstractÄƒ
Dar Z nu e declaratÄƒ abstract, deci este obligatÄƒ sÄƒ implementeze f().
â†’ B este corect.
Z trebuie sÄƒ implementeze f(), altfel avem eroare.


9. Ce se Ã®ntÃ¢mplÄƒ?
interface I {
    static void f() {}
}

class A implements I {
    void test() {
        f();
    }
}

A. CompileazÄƒ
B. Eroare: trebuie scris I.f()
C. Eroare: f() nu poate fi static
D. Eroare: test() trebuie sÄƒ fie static

âœ” CORECT: B
ExplicaÈ›ie esenÈ›ialÄƒ:
Metodele statice din interfeÈ›e NU sunt moÈ™tenite de clasele care le implementeazÄƒ.
interface I { static void f() {} }
class A implements I {
    void test() {
        f(); // âŒ eroare
    }
}
Trebuie:
I.f();  // âœ”



10. Ce este adevÄƒrat?
A. O clasÄƒ abstractÄƒ trebuie sÄƒ implementeze toate metodele interfeÈ›ei pe care o implementeazÄƒ
B. InterfeÈ›ele pot extinde alte interfeÈ›e
C. Metodele abstracte pot fi private
D. Clasa abstractÄƒ nu poate avea cÃ¢mpuri

InterfeÈ›ele pot extinde alte interfeÈ›e (moÈ™tenire multiplÄƒ).
Celelalte sunt false.















