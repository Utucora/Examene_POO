ğŸ”¹ 1. Ierarhia excepÈ›iilor
Object
 â””â”€â”€ Throwable
      â”œâ”€â”€ Error
      â””â”€â”€ Exception
           â”œâ”€â”€ RuntimeException  (unchecked)
           â””â”€â”€ NO RuntimeException (checked)
âœ” Checked exceptions
â†’ trebuie tratate Ã®n cod sau declarate cu throws.
Exemple:
IOException
FileNotFoundException
SQLException
âœ” Unchecked exceptions
â†’ NU trebuie tratate
â†’ apar Ã®n majoritatea grilelor.
Exemple:
NullPointerException
ArrayIndexOutOfBoundsException
ArithmeticException
ClassCastException
IllegalArgumentException
NumberFormatException


ğŸ”¹ 2. try / catch / finally
âœ” finally se executÄƒ Ã®ntotdeauna
â†’ chiar dacÄƒ ai return Ã®n try
â†’ chiar dacÄƒ ai excepÈ›ie
â†’ chiar dacÄƒ ai alt return Ã®n catch
â†’ SINGURA situaÈ›ie cÃ¢nd nu se executÄƒ: se opreÈ™te JVM (System.exit())
âœ” poÈ›i avea try fÄƒrÄƒ catch, dar cu finally:
try { ... } finally { ... }



ğŸ”¹ 3. Ordinea blocurilor catch (capcanÄƒ)
Se prind excepÈ›iile de la cel mai specific la cel mai general.
Exemplu GREÈ˜IT:
catch(Exception e) {}
catch(IOException e) {} // never reached â†’ eroare



ğŸ”¹ 4. propagate vs handle
handle: ai try/catch
propagate: foloseÈ™ti throws Exception


ğŸ”¹ 5. Cele mai importante excepÈ›ii (apar Ã®n 90% din grile)

âœ” NullPointerException
String s = null;
s.length(); // NPE

âœ” ArrayIndexOutOfBoundsException
int[] a = new int[3];
a[5] = 1; // out of bounds

âœ” ClassCastException
Object o = "abc";
Integer x = (Integer) o; // ClassCastException

âœ” ArithmeticException
int x = 5 / 0;

âœ” NumberFormatException
Integer.parseInt("abc");

âœ” IllegalArgumentException
Thread.sleep(-5);


ğŸ”¹ 6. CAPCANE try/catch/finally

CAPCANA #1

Return Ã®n try, finally se executÄƒ oricum:
try {
    return 1;
} finally {
    System.out.println("finally");
}
Tipic rezultat:
â†’ se afiÈ™eazÄƒ "finally"
â†’ metoda returneazÄƒ 1


CAPCANA #2

DacÄƒ finally are return â†’ anuleazÄƒ orice alt return:
try {
    return 1;
} finally {
    return 2;
}
Rezultat: 2
âš ï¸ Ãntrerupe complet logica metodei.


CAPCANA #3

ExcepÈ›ia aruncatÄƒ Ã®n finally suprascrie excepÈ›ia din try.
try {
    throw new RuntimeException("A");
} finally {
    throw new RuntimeException("B");
}
Rezultatul: DOAR â€œBâ€ se propagate.
