ğŸ”¹ I. STRUCTURA DE BAZÄ‚ A UNEI CLASE
O clasÄƒ Ã®n Java e È™ablonul pentru obiecte.
O clasÄƒ poate conÈ›ine:
Atribute (fields) â†’ starea obiectului
Metode â†’ comportamentul obiectului
Constructori â†’ iniÈ›ializeazÄƒ obiectele
Blocuri static / initializer
Clase interne / enum / inte

public class Student {
    private String name;      // atribut
    private int year;

    // Constructor
    public Student(String name, int year) {
        this.name = name;
        this.year = year;
    }

    // MetodÄƒ
    public void print() {
        System.out.println(name + " " + year);
    }
}



ğŸ”¹ II. STATIC
static = membru aparÈ›inÃ¢nd clasei, nu instanÈ›ei.

class Counter {
    static int count = 0;  // comun tuturor obiectelor
    Counter() { count++; }
}

public class Test {
    public static void main(String[] args) {
        new Counter();
        new Counter();
        System.out.println(Counter.count); // 2
    }
}


static â†’ accesat fÄƒrÄƒ obiect (Counter.count)
metodele static nu pot accesa membri non-statici
static poate fi folosit È™i pentru blocuri de iniÈ›ializare:



ğŸ”¹ III. THIS
this = referinÈ›Äƒ la obiectul curent.
Folosiri:

1. DeosebeÈ™te parametrii de cÃ¢mpuri:

this.name = name;

2. ApeleazÄƒ alÈ›i constructori:
public Student(String name) {
    this(name, 1);
}

3. Poate fi returnat:
public Student getSelf() { return this; }

ğŸ”¹ IV. SUPER
super = referinÈ›Äƒ la superclasÄƒ (pÄƒrinte).
Folosiri:

1. ApeleazÄƒ constructorul superclasei:

class A { A(String s) {} }
class B extends A {
    B() { super("hello"); }
}


2.

AcceseazÄƒ metode / cÃ¢mpuri suprascrise:
class Parent { void show() { System.out.println("Parent"); } }
class Child extends Parent {
    void show() {
        super.show(); // apeleazÄƒ metoda din Parent
        System.out.println("Child");
    }
}

Reguli:
apelul super() trebuie sÄƒ fie prima linie Ã®n constructor
dacÄƒ nu este scris explicit, se apeleazÄƒ implicit super() (fÄƒrÄƒ parametri)


âš™ï¸ Recapitulare scurtÄƒ:
Concept	ReprezintÄƒ	     Poate accesa membri instanÈ›Äƒ?	Poate fi folosit Ã®n static?
static	aparÈ›ine clasei	               âŒ	                        âœ…
this	  instanÈ›a curentÄƒ	             âœ…                         âŒ
super	  superclasa	                   âœ…	                        âŒ




âœ… ÃNTREBAREA 1
class A { static int x = 10; }
class B extends A { static int x = 20; }

public class Test {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.x);
    }
}

A. 10
B. 20
C. eroare la compilare
D. null


ğŸŸ© RÄƒspuns corect: A. 10
ExplicaÈ›ie:
x este static, deci aparÈ›ine clasei, nu obiectului.
DeÈ™i faci new B(), referinÈ›a este de tip A, deci variabila staticÄƒ se rezolvÄƒ la tipul compile-time, nu runtime.
Deci a.x este acelaÈ™i cu A.x

ğŸ‘‰ Upcasting: A a = new B(); Ã®nseamnÄƒ:
Obiectul real este B (instanÈ›Äƒ a subclasei).
ReferinÈ›a este de tip A (superclasÄƒ).
Se pot accesa doar membrii (metode/cÃ¢mpuri) vizibili Ã®n tipul A.
Pentru metode override, se apeleazÄƒ implementarea din B (dynamic dispatch).
Pentru cÃ¢mpuri statici, nu existÄƒ overriding, deci se ia A.x

ğŸ”¹ Ce e upcast-ul (foarte important la examen):
Upcast = conversia unei referinÈ›e de subclasÄƒ la o referinÈ›Äƒ de superclasÄƒ.
Exemplu:
Dog d = new Dog();
Animal a = d; // upcast
Sigur, automat, fÄƒrÄƒ cast.
Scop: tratÄƒm mai multe tipuri ca pe un singur tip comun.
Exemplu practic:
List<String> list = new ArrayList<>();
â€” ArrayList e subclasÄƒ, List e super-interfaÈ›Äƒ â‡’ upcast util.

ğŸ”¹ Ce e downcast-ul:
Downcast = transformarea unei referinÈ›e de superclasÄƒ Ã®n subclasÄƒ.
Exemplu:
Animal a = new Dog();
Dog d = (Dog) a; // downcast corect
Dar:
Animal a = new Animal();
Dog d = (Dog) a; // ClassCastException!

âš ï¸ Downcast greÈ™it â†’ runtime error (ClassCastException)
ğŸ’£ Capcane la examen:
Static vs override â€” static se rezolvÄƒ la compile-time, override la run-time.
â€œCe se afiÈ™eazÄƒ dacÄƒ metoda e staticÄƒ?â€ â€” Ã®ntotdeauna se foloseÈ™te tipul referinÈ›ei.
â€œUpcastul este Ã®ntotdeauna sigur?â€ âœ…
â€œDowncastul este Ã®ntotdeauna sigur?â€ âŒ (poate da excepÈ›ie).

















