ğŸ”¹ I. STRUCTURA DE BAZÄ‚ A UNEI CLASE
O clasÄƒ Ã®n Java e È™ablonul pentru obiecte.
O clasÄƒ poate conÈ›ine:
Atribute (fields) â†’ starea obiectului
Metode â†’ comportamentul obiectului
Constructori â†’ iniÈ›ializeazÄƒ obiectele
Blocuri static / initializer
Clase interne / enum / inte

public class Student {
    private String name;      // atribut
    private int year;

    // Constructor
    public Student(String name, int year) {
        this.name = name;
        this.year = year;
    }

    // MetodÄƒ
    public void print() {
        System.out.println(name + " " + year);
    }
}



ğŸ”¹ II. STATIC
static = membru aparÈ›inÃ¢nd clasei, nu instanÈ›ei.

class Counter {
    static int count = 0;  // comun tuturor obiectelor
    Counter() { count++; }
}

public class Test {
    public static void main(String[] args) {
        new Counter();
        new Counter();
        System.out.println(Counter.count); // 2
    }
}


static â†’ accesat fÄƒrÄƒ obiect (Counter.count)
metodele static nu pot accesa membri non-statici
static poate fi folosit È™i pentru blocuri de iniÈ›ializare:



ğŸ”¹ III. THIS
this = referinÈ›Äƒ la obiectul curent.
Folosiri:

1. DeosebeÈ™te parametrii de cÃ¢mpuri:

this.name = name;

2. ApeleazÄƒ alÈ›i constructori:
public Student(String name) {
    this(name, 1);
}

3. Poate fi returnat:
public Student getSelf() { return this; }

ğŸ”¹ IV. SUPER
super = referinÈ›Äƒ la superclasÄƒ (pÄƒrinte).
Folosiri:

1. ApeleazÄƒ constructorul superclasei:

class A { A(String s) {} }
class B extends A {
    B() { super("hello"); }
}


2.

AcceseazÄƒ metode / cÃ¢mpuri suprascrise:
class Parent { void show() { System.out.println("Parent"); } }
class Child extends Parent {
    void show() {
        super.show(); // apeleazÄƒ metoda din Parent
        System.out.println("Child");
    }
}

Reguli:
apelul super() trebuie sÄƒ fie prima linie Ã®n constructor
dacÄƒ nu este scris explicit, se apeleazÄƒ implicit super() (fÄƒrÄƒ parametri)


âš™ï¸ Recapitulare scurtÄƒ:
Concept	ReprezintÄƒ	     Poate accesa membri instanÈ›Äƒ?	Poate fi folosit Ã®n static?
static	aparÈ›ine clasei	               âŒ	                        âœ…
this	  instanÈ›a curentÄƒ	             âœ…                         âŒ
super	  superclasa	                   âœ…	                        âŒ




âœ… ÃNTREBAREA 1
class A { static int x = 10; }
class B extends A { static int x = 20; }

public class Test {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.x);
    }
}

A. 10
B. 20
C. eroare la compilare
D. null


ğŸŸ© RÄƒspuns corect: A. 10
ExplicaÈ›ie:
x este static, deci aparÈ›ine clasei, nu obiectului.
DeÈ™i faci new B(), referinÈ›a este de tip A, deci variabila staticÄƒ se rezolvÄƒ la tipul compile-time, nu runtime.
Deci a.x este acelaÈ™i cu A.x

ğŸ‘‰ Upcasting: A a = new B(); Ã®nseamnÄƒ:
Obiectul real este B (instanÈ›Äƒ a subclasei).
ReferinÈ›a este de tip A (superclasÄƒ).
Se pot accesa doar membrii (metode/cÃ¢mpuri) vizibili Ã®n tipul A.
Pentru metode override, se apeleazÄƒ implementarea din B (dynamic dispatch).
Pentru cÃ¢mpuri statici, nu existÄƒ overriding, deci se ia A.x

ğŸ”¹ Ce e upcast-ul (foarte important la examen):
Upcast = conversia unei referinÈ›e de subclasÄƒ la o referinÈ›Äƒ de superclasÄƒ.
Exemplu:
Dog d = new Dog();
Animal a = d; // upcast
Sigur, automat, fÄƒrÄƒ cast.
Scop: tratÄƒm mai multe tipuri ca pe un singur tip comun.
Exemplu practic:
List<String> list = new ArrayList<>();
â€” ArrayList e subclasÄƒ, List e super-interfaÈ›Äƒ â‡’ upcast util.

ğŸ”¹ Ce e downcast-ul:
Downcast = transformarea unei referinÈ›e de superclasÄƒ Ã®n subclasÄƒ.
Exemplu:
Animal a = new Dog();
Dog d = (Dog) a; // downcast corect
Dar:
Animal a = new Animal();
Dog d = (Dog) a; // ClassCastException!

âš ï¸ Downcast greÈ™it â†’ runtime error (ClassCastException)
ğŸ’£ Capcane la examen:
Static vs override â€” static se rezolvÄƒ la compile-time, override la run-time.
â€œCe se afiÈ™eazÄƒ dacÄƒ metoda e staticÄƒ?â€ â€” Ã®ntotdeauna se foloseÈ™te tipul referinÈ›ei.
â€œUpcastul este Ã®ntotdeauna sigur?â€ âœ…
â€œDowncastul este Ã®ntotdeauna sigur?â€ âŒ (poate da excepÈ›ie).



âœ… ÃNTREBAREA 2
class Example {
    int a = 10;
    static int b = 20;

    void f() { System.out.println(a + b); }
    static void g() { System.out.println(a + b); }
}
ğŸŸ© Corect: B. Eroare â€“ metoda staticÄƒ nu poate accesa a.
âœ” a e non-static, aparÈ›ine unui obiect.
âœ” g() e static â€” aparÈ›ine clasei, nu are acces la this.
âŒ deci System.out.println(a + b) â†’ eroare de compilare: non-static variable a cannot be referenced from a static context.



âœ… ÃNTREBAREA 3
class A { A() { System.out.println("A"); } }
class B extends A {
    B() {
        super();
        System.out.println("B");
    }
}
ğŸŸ© Corect: C. se afiÈ™eazÄƒ A apoi B.
âœ” super() apeleazÄƒ constructorul clasei pÄƒrinte.
âœ” Chiar dacÄƒ nu ai scrie super(), Java Ã®l pune implicit ca prima linie Ã®n constructor.
Deci oricum s-ar afiÈ™a A, apoi B.




âœ… ÃNTREBAREA 4
class A { A() { System.out.println("A"); } }
class B extends A {
    B() { this(5); System.out.println("B"); }
    B(int x) { System.out.println("B int"); }
}
ğŸŸ© Corect: C. A â†’ B int â†’ B
âœ” Ordinea:
new B() â†’ apeleazÄƒ constructorul fÄƒrÄƒ parametri
this(5) â†’ apeleazÄƒ constructorul B(int)
Ã®nainte de B(int), se apeleazÄƒ implicit super() (â†’ A)
apoi B int
apoi B
â¡ï¸ deci A â†’ B int â†’ B

ğŸ’¬ DiferenÈ›a â€œparametruâ€ vs â€œargumentâ€:
Parametru = variabila definitÄƒ Ã®n semnÄƒtura metodei (int x)
Argument = valoarea efectivÄƒ transmisÄƒ la apel (this(5) â†’ 5 e argument)


âœ… ÃNTREBAREA 5
class Demo {
    int x = 5;
    Demo() { System.out.println(this.x); }
}
ğŸŸ© Corect: B. 5
âœ” x e iniÈ›ializat la 5 Ã®nainte de executarea constructorului.
âœ” this se referÄƒ la instanÈ›a curentÄƒ.




6. Ce este adevÄƒrat despre this?
A. poate fi folosit Ã®ntr-o metodÄƒ staticÄƒ
B. poate apela alt constructor din aceeaÈ™i clasÄƒ
C. se referÄƒ la superclasÄƒ
D. poate fi folosit Ã®nainte de super()

âœ… ÃNTREBAREA 6
ğŸŸ© Corect: B. poate apela alt constructor din aceeaÈ™i clasÄƒ.
âœ” this(...) â†’ apeleazÄƒ alt constructor
âœ” nu poate fi folosit Ã®n static context
âœ” this() trebuie sÄƒ fie prima linie din constructor




âœ… ÃNTREBAREA 7
ğŸŸ© Corect: B. super() trebuie sÄƒ fie prima instrucÈ›iune din constructor.
âœ” altfel â†’ eroare de compilare (â€œConstructor call must be the first statementâ€).


âœ… ÃNTREBAREA 8
class A { int x = 10; }
class B extends A {
    int x = 20;
    void print() { System.out.println(super.x); }
}
ğŸŸ© Corect: A. 10
âœ” super.x acceseazÄƒ atributul clasei pÄƒrinte chiar dacÄƒ e ascuns de cel din subclasÄƒ.
âœ” nu e eroare â€” shadowing (ascunderea variabilei pÄƒrinte) e permis Ã®n Java.




9. Ce afiÈ™eazÄƒ:
class Counter {
    static int count = 0;
    Counter() { count++; }
}

public class Main {
    public static void main(String[] args) {
        new Counter();
        new Counter();
        Counter c = new Counter();
        System.out.println(c.count);
    }
}
A. 1
B. 2
C. 3
D. 0


âœ… ÃNTREBAREA 9
ğŸŸ© Corect: C. 3
âœ” Fiecare new Counter() incrementeazÄƒ count.
âœ” E static â†’ comun tuturor instanÈ›elor.
âœ” DupÄƒ 3 apeluri, count = 3.




10. Ce se Ã®ntÃ¢mplÄƒ dacÄƒ NU apelÄƒm explicit super() Ã®ntr-un constructor de subclasÄƒ?
A. se apeleazÄƒ automat super() fÄƒrÄƒ parametri
B. programul nu compileazÄƒ niciodatÄƒ
C. se apeleazÄƒ this()
D. superclasa nu este iniÈ›ializatÄƒ

âœ… ÃNTREBAREA 10
ğŸŸ© Corect: A. dacÄƒ nu apelÄƒm explicit super(), Java apeleazÄƒ implicit constructorul fÄƒrÄƒ parametri din superclasÄƒ.
âœ” DacÄƒ superclasa nu are constructor fÄƒrÄƒ parametri, compilarea eÈ™ueazÄƒ.





ğŸ”¥ REZUMAT FOARTE SCURT â€“ TOT CE TREBUIE SÄ‚ REÈšII AICI
Concept	                EsenÈ›ial
static	                aparÈ›ine clasei, nu obiectului; metodele statice nu acceseazÄƒ this; nu se moÈ™tenesc dinamic
this	                referinÈ›Äƒ la instanÈ›a curentÄƒ; folosit Ã®n constructori; NU se poate Ã®n static
super	                referinÈ›Äƒ la superclasÄƒ; apeleazÄƒ constructorul pÄƒrinte; prima linie Ã®n constructor
upcast	                sigur, automatÄƒ; tratezi subclasa ca superclasÄƒ; folosit Ã®n polimorfism
downcast            	manual, riscant; poate da ClassCastException
constructori	        nu se moÈ™tenesc; apel implicit super() dacÄƒ nu e scris
