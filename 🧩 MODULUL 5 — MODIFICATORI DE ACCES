(public / private / protected / default)

ğŸŸ¦ I. TEORIE ESENÈšIALÄ‚ (TOT CE TREBUIE SÄ‚ È˜TII PENTRU EXAMEN)
Java are 4 modificatori de acces:
public
private
protected
(default) â†’ fÄƒrÄƒ modificator
Ei controleazÄƒ vizibilitatea Ã®n clase, pachete È™i moÈ™tenire.

ğŸ”¥ 1. public
Cel mai permisiv.
â†’ poate fi accesat de oriunde.
public int x = 5;
Se aplicÄƒ la:
clase (doar top-level)
metode
atribute
constructori


ğŸ”¥ 2. private
Cel mai restrictiv.
â†’ accesibil numai Ã®n clasa Ã®n care e definit.
private int x = 5;
Important:
NU poate fi accesat Ã®n subclasÄƒ
NU poate fi accesat din acelaÈ™i pachet
DOAR clasa curentÄƒ Ã®l poate vedea
metodele private NU se pot suprascrie (nici mÄƒcar nu existÄƒ Ã®n subclasÄƒ!)


ğŸ”¥ 3. default (fÄƒrÄƒ modificator)
DacÄƒ nu scrii nimic:
int x = 5;   // default
â†’ vizibil Ã®n acelaÈ™i pachet
â†’ NU vizibil Ã®n alte pachete
â†’ NU vizibil Ã®n subclase din pachete diferite
Foarte des apare Ã®n grile ca:
â€œVizibil doar Ã®n pachet â†’ defaultâ€.


ğŸ”¥ 4. protected
AICI E CAPCANA MARE.
â†’ Vizibil Ã®n:
clasa curentÄƒ
acelaÈ™i pachet
subclase (chiar È™i din pachete diferite!)
Dar ATENÈšIE:
Ãntr-o subclasÄƒ din alt pachet poÈ›i accesa protected NUMAI prin moÈ™tenire, NU prin obiect.
Exemplu (capcanÄƒ realÄƒ la examen):
package p1;
public class A {
    protected int x = 5;
}

package p2;
class B extends A {
    void f() {
        System.out.println(x);       // âœ” ok
        A a = new A();
        // System.out.println(a.x);  // âŒ eroare
    }
}




ğŸŸ¦ II. TABEL REZUMAT (foarte important la examene)
Modificator    	Ãn aceeaÈ™i clasÄƒ	Ãn acelaÈ™i pachet	      Ãn subclasÄƒ ACELAÈ˜I pachet	Ãn subclasÄƒ ALT pachet	          Ãn afara pachetului (fÄƒrÄƒ moÈ™tenire)
public	            âœ”	                  âœ”	                      âœ”                            	âœ”                                	âœ”
protected	          âœ”	                  âœ”	                      âœ”	                            âœ” (dar doar prin this/super)	    âŒ
default	            âœ”	                  âœ”	                      âœ”	                            âŒ	                              âŒ
private	            âœ”	                  âŒ	                    âŒ	                          âŒ	                              âŒ


Cel mai bun mod de a reÈ›ine:
public > protected > default > private


ğŸŸ¦ III. EXEMPLE RELEVANTE (care picÄƒ Ã®n grile)
1. private NU poate fi accesat Ã®n subclasÄƒ
class A {
    private int x = 10;
}

class B extends A {
    void f() {
        // System.out.println(x); // âŒ eroare
    }
}

2. default NU trece graniÈ›a de pachet
package p1;
class A {
    int x = 3; // default
}
package p2;
class B {
    void f() {
        A a = new A();
        // a.x; // âŒ
    }
}
3. protected Ã®n alt pachet: se poate ACCESA DOAR PRIN MOÈ˜TENIRE
package p1;
public class A {
    protected int x = 10;
}
package p2;
public class B extends A {
    void f() {
        System.out.println(this.x); // âœ” OK
        A a = new A();
        // System.out.println(a.x); // âŒ NU merge!
    }
}






1. Ce este adevÄƒrat despre private?
A. poate fi accesat Ã®n subclasÄƒ
B. poate fi accesat doar Ã®n clasa curentÄƒ
C. este vizibil Ã®n acelaÈ™i pachet
D. poate fi accesat doar prin moÈ™tenire

âœ” CORECT: B â€” private = vizibil doar Ã®n clasa curentÄƒ
nu se vede Ã®n subclasÄƒ
nu se vede Ã®n acelaÈ™i pachet
nu se moÈ™teneÈ™te Ã®n sensul de accesibilitate


2. DacÄƒ o metodÄƒ are modificator default, unde este vizibilÄƒ?
A. doar Ã®n clasa curentÄƒ
B. Ã®n clasa curentÄƒ È™i Ã®n acelaÈ™i pachet
C. doar Ã®n subclase
D. Ã®n toate pachetele

âœ” CORECT: B â€” default = vizibil Ã®n acelaÈ™i pachet
Exact, default = package-private.
Foarte mulÈ›i studenÈ›i cred cÄƒ â€œdefaultâ€ Ã®nseamnÄƒ ceva legat de moÈ™tenire â€” greÈ™it.



3. Ce se Ã®ntÃ¢mplÄƒ?
package p1;
public class A {
    protected int x = 4;
}

package p2;
public class B extends A {
    void f() {
        A a = new A();
        System.out.println(a.x);
    }
}
A. afiÈ™eazÄƒ 4
B. eroare de compilare
C. afiÈ™eazÄƒ un garbage value
D. afiÈ™eazÄƒ 0


âœ” CORECT: B â€” eroare de compilare
SituaÈ›ia clasicÄƒ:
A a = new A();
System.out.println(a.x); // Ã®n alt pachet â†’ NU merge
Protected Ã®n alt pachet merge NUMAI prin moÈ™tenire, adicÄƒ:
System.out.println(this.x); // OK
dar NU prin:
a.x; // âŒ



4. Ce se Ã®ntÃ¢mplÄƒ?
class A {
    private int x = 10;
}
class B extends A {
    void f() {
        System.out.println(x);
    }
}
A. afiÈ™eazÄƒ 10
B. afiÈ™eazÄƒ 0
C. eroare: x este privat
D. afiÈ™eazÄƒ null

âœ” CORECT: C â€” x este privat È™i nu poate fi accesat Ã®n subclasÄƒ
class A { private int x; }
class B extends A { void f() { x; } } // eroare
Important:
private nu se moÈ™teneÈ™te Ã®n sensul de vizibilitate
se moÈ™teneÈ™te ca â€œparte a obiectuluiâ€, dar nu ai acces la el




5. protected permite acces din alt pachet dacÄƒ:
A. clasa este finalÄƒ
B. membrul este accesat printr-un obiect al clasei pÄƒrinte
C. membrul este accesat prin moÈ™tenire (prin this/super)
D. membrul este static

âœ” CORECT: C â€” protected funcÈ›ioneazÄƒ Ã®ntre pachete doar prin moÈ™tenire
Foarte important la examen:
âœ” poÈ›i scrie:
this.x;
super.x;
âŒ dar NU poÈ›i scrie:
new A().x; // eroare Ã®n alt pachet



6. O clasÄƒ fÄƒrÄƒ modificator este:
A. public
B. private
C. default (package-private)
D. protected

âœ” CORECT: C â€” default (package-private)
O clasÄƒ fÄƒrÄƒ modificator este vizibilÄƒ doar Ã®n pachet.


7. Metodele private:
A. se pot suprascrie
B. nu se pot suprascrie
C. pot fi accesate Ã®n subclase
D. pot fi apelate prin obiecte din alte pachete

âœ” CORECT: B â€” metodele private NU se pot suprascrie
ExplicaÈ›ie importantÄƒ:
De fapt, dacÄƒ ai:
class A { private void f(){} }
class B extends A { private void f(){} }
Metoda din B NU este overriding, ci este o metodÄƒ complet nouÄƒ â†’ metodele private nu participÄƒ la polimorfism.






