ğŸŸ¦ I. Teorie esenÈ›ialÄƒ â€“ tot ce poate pica la examen

ğŸ”¹ 1. Ce este polimorfismul
Polimorfism = posibilitatea de a trata mai multe obiecte diferite printr-o singurÄƒ interfaÈ›Äƒ (tip comun).
AdicÄƒ:
Animal a = new Dog();
Animal b = new Cat();
Ambele sunt Animal, dar se comportÄƒ diferit.

ğŸ”¹ 2. Upcasting (super important!)
Upcast = cÃ¢nd o referinÈ›Äƒ de subclasÄƒ este tratatÄƒ ca superclasÄƒ.
Exemplu:
Dog d = new Dog();
Animal a = d;  // upcast

âœ” Este sigur
âœ” Se face automat
âœ” Se foloseÈ™te la polimorfism
La upcast, apelurile de metode sunt rezolvate la RUNTIME â†’ dynamic dispatch (late binding).
Exemplu:
Animal a = new Dog();
a.speak();   // apeleazÄƒ Dog.speak()


ğŸ”¹ 3. Downcasting
Downcast = transformi o referinÈ›Äƒ de superclasÄƒ Ã®n subclasÄƒ.
Exemplu:

Animal a = new Dog();
Dog d = (Dog) a;

âœ” dacÄƒ obiectul real este Dog â†’ OK

âŒ dacÄƒ NU â†’ ClassCastException
Exemplu greÈ™it:

Animal a = new Animal();
Dog d = (Dog) a;  // runtime error!



ğŸ”¹ 4. Overriding (suprascriere)
O subclasÄƒ redefineÈ™te o metodÄƒ din superclasÄƒ cu aceeaÈ™i semnÄƒturÄƒ.
Exemplu:
class A { void f() { System.out.println("A"); } }
class B extends A {
    @Override
    void f() { System.out.println("B"); }
}


Reguli:
semnÄƒtura trebuie sÄƒ fie IDENTICÄ‚
tipul return poate fi covariant
accesul poate fi mÄƒrit (protected â†’ public), dar nu scÄƒzut
DOAR metodele de instanÈ›Äƒ se suprascriu
static NU se poate suprascrie â†’ doar hiding
Super important:
Apelul metodei override se alege la runtime â†’ late binding.


ğŸ”¹ 5. Overloading (supraincÄƒrcare)
DouÄƒ metode cu acelaÈ™i nume, dar semnÄƒturi diferite.
Exemplu:
void f(int x) {}
void f(double y) {}
void f(int x, int y) {}
Reguli:
trebuie schimbat: numÄƒr/ordine/tip parametri
tipul de return NU conteazÄƒ
se rezolvÄƒ la compilare â†’ early binding


ğŸ”¹ 6. Hiding vs Overriding
SituaÈ›ie	          Ce se Ã®ntÃ¢mplÄƒ
metodÄƒ non-static	  overriding
metodÄƒ static	      hiding (nu e overriding)
atribute	          hiding (niciodatÄƒ overriding)
Exemplu:

class A { static void f() {} }
class B extends A { static void f() {} }  // hiding, nu override
Apelul se rezolvÄƒ dupÄƒ tipul referinÈ›ei, nu al obiectului.


ğŸ”¹ 7. Binding (legare)
Tip	                    CÃ¢nd?	              Exemple
Early binding	      la compilare  	overloading, static, private
Late binding	      la runtime	          overriding



ğŸ”¹ 8. Tip static vs tip dinamic
Tip static â†’ tipul referinÈ›ei (compile-time)
Tip dinamic â†’ tipul obiectului real (runtime)
Exemplu:
Animal a = new Dog();
tip static: Animal
tip dinamic: Dog
La examen apar Ã®ntrebÄƒri:
â€œCe metodÄƒ se apeleazÄƒ?â€ â†’ dupÄƒ tipul dinamic
â€œCe membru se acceseazÄƒ?â€ â†’ dupÄƒ tipul static








1. Ce se afiÈ™eazÄƒ?
class A {
    void f() { System.out.println("A"); }
}

class B extends A {
    void f() { System.out.println("B"); }
}

public class Main {
    public static void main(String[] args) {
        A a = new B();
        a.f();
    }
}
A. A
B. B
C. eroare
D. depinde de compilator



2. Ce se afiÈ™eazÄƒ?
class A {
    static void f() { System.out.println("A"); }
}
class B extends A {
    static void f() { System.out.println("B"); }
}

public class Main {
    public static void main(String[] args) {
        A a = new B();
        a.f();
    }
}
A. A
B. B
C. eroare
D. NullPointerException


3. Ce se Ã®ntÃ¢mplÄƒ?
Animal a = new Dog();
Dog d = (Dog) a;
A. compileazÄƒ È™i ruleazÄƒ
B. compileazÄƒ dar dÄƒ runtime error
C. eroare la compilare
D. eroare doar dacÄƒ Dog nu suprascrie metode


4. Ce se Ã®ntÃ¢mplÄƒ?
Animal a = new Animal();
Dog d = (Dog) a;
A. compileazÄƒ fÄƒrÄƒ eroare
B. runtime error (ClassCastException)
C. eroare la compilare
D. ruleazÄƒ normal


5. Ce este adevÄƒrat despre overriding?
A. tipul de return nu poate fi schimbat niciodatÄƒ
B. metoda din subclasÄƒ trebuie sÄƒ fie staticÄƒ
C. accesul poate deveni mai permisiv (ex. protected â†’ public)
D. metoda suprascrisÄƒ trebuie sÄƒ fie final


6. SelectaÈ›i afirmaÈ›ia corectÄƒ despre overloading:
A. se bazeazÄƒ pe numele metodei È™i tipul de return
B. se bazeazÄƒ pe semnÄƒtura metodei
C. necesitÄƒ moÈ™tenire
D. se decide la runtime


7. Ce se afiÈ™eazÄƒ?
class A {
    void f(int x) { System.out.println("int"); }
    void f(double x) { System.out.println("double"); }
}

public class Main {
    public static void main(String[] args) {
        A a = new A();
        a.f(5);
    }
}
A. int
B. double
C. eroare
D. depinde de VM



8. Ce se afiÈ™eazÄƒ?
class A {
    void f(Object o) { System.out.println("Object"); }
}
class B extends A {
    void f(String s) { System.out.println("String"); }
}

public class Main {
    public static void main(String[] args) {
        A a = new B();
        a.f("abc");
    }
}
A. Object
B. String
C. eroare
D. null




9. Care metodÄƒ se apeleazÄƒ?
class A {
    void f() { System.out.println("A"); }
}
class B extends A {
    void f() { System.out.println("B"); }
}
class C extends B {
    void f() { System.out.println("C"); }
}

public class Main {
    public static void main(String[] args) {
        A a = new C();
        a.f();
    }
}
A. A
B. B
C. C
D. eroare





10. Ce tip de binding se foloseÈ™te la overriding?
A. static
B. early
C. late
D. compile-time




1. B deoarece metoda se ia din tipul dinamic. Pentru metode non-statice (override), se aplicÄƒ 
dynamic dispatch (late binding) â†’ se ia implementarea din tipul dinamic (B).

2. A, functia din clasa B isi ia hide deoarece e statica si nu poate fi overriden
Metodele static NU se suprascriu â†’ se ascund (hiding).
Aici conteazÄƒ tipul static al referinÈ›ei (A a).
Deci se executÄƒ A.f().

3. A, compileaza si ruleaza deoarece obiectul real(a) este dog 
Obiectul real este Dog, deci downcast-ul este valid.
Animal a = new Dog(); // ok
Dog d = (Dog) a;      // ok


4. B, runtime error ClassCastException 
nimal a = new Animal();
Dog d = (Dog) a; // ClassCastException
Obiectul real NU este Dog â†’ runtime error.


5. C, metoda suprascrisa poate devenni mai permisiva 
RegulÄƒ importantÄƒ:
Ã®n overriding poÈ›i mÄƒri nivelul de acces (protected â†’ public)
nu ai voie sÄƒ Ã®l restrÃ¢ngi


6. B
RÄƒspuns corect: B
ExplicaÈ›ie:
Overloading nu necesitÄƒ moÈ™tenire â€” absolut deloc.
FuncÈ›ioneazÄƒ complet Ã®n interiorul aceleiaÈ™i clase, chiar È™i fÄƒrÄƒ nicio moÈ™tenire.
Exemplu:
void f(int x) {}
void f(double y) {}
Asta este supraincÄƒrcare.
Regula exactÄƒ:
Overloading se bazeazÄƒ pe semnÄƒtura metodei.
Deci rÄƒspunsul corect este:
B. se bazeazÄƒ pe semnÄƒtura metodei




7. A, int, deoarece argumentul pasat e de tip int
a.f(5); // 5 e literal int â†’ se apeleazÄƒ metoda cu parametru int




8.  A, Object
âœ” RÄƒspuns corect: A â€” â€œObjectâ€
Aici e capcana supremÄƒ È™i toÈ›i studenÈ›ii calcÄƒ Ã®n ea:
ExplicaÈ›ie importantÄƒ:
Polimorfismul (dynamic dispatch) funcÈ›ioneazÄƒ doar pentru override, NU pentru overload.
Aici NU ai overriding. Ai overloading Ã®n B.
Cod:
class A {
    void f(Object o) { System.out.println("Object"); }
}

class B extends A {
    void f(String s) { System.out.println("String"); }
}
Ãn main:
A a = new B(); 
a.f("abc");
Ce metode sunt vizibile din tipul A?
â†’ doar f(Object)
f(String) NU este vizibil prin referinÈ›Äƒ de tip A.
Deci se apeleazÄƒ A.f(Object), cu "abc" convertit la Object.
â¡ï¸ Output: "Object"





9. C , C
Este overriding pe 3 niveluri.
Dynamic dispatch â†’ se ia metoda din tipul dinamic C.

10. C, late binding
Overriding foloseÈ™te late binding (dynamic dispatch).









